import{s as a}from"./index-CvO9pKPC.js";class p{conversationSubscriptions=new Map;async ensureUserProfileExists(e){try{const{data:r}=await a.from("users").select("id").eq("id",e).single();if(r)return!0;const{data:{user:t}}=await a.auth.getUser();if(t&&t.id===e){const{error:n}=await a.from("users").insert({id:t.id,email:t.email,name:t.user_metadata?.name||t.email?.split("@")[0]||"User",nickname:t.user_metadata?.nickname,phone:t.phone,avatar:t.user_metadata?.avatar_url,created_at:t.created_at,updated_at:t.updated_at||t.created_at});return n?(console.error("Error creating user profile:",n),!1):!0}return console.warn(`User profile not found for userId: ${e}. They may need to complete signup.`),!1}catch(r){return console.error("Error ensuring user profile exists:",r),!1}}async getOrCreateConversation(e){try{const{data:{user:r}}=await a.auth.getUser();if(!r)throw new Error("User not authenticated");const t=await this.ensureUserProfileExists(r.id),n=await this.ensureUserProfileExists(e.participant_user_id);if(!t||!n)throw new Error("Failed to ensure user profiles exist in database");const{data:s}=await a.from("conversation_participants").select("conversation_id").eq("user_id",r.id);if(s&&s.length>0){const d=s.map(_=>_.conversation_id),{data:u}=await a.from("conversation_participants").select("conversation_id").eq("user_id",e.participant_user_id).in("conversation_id",d);if(u&&u.length>0){const _=u.map(g=>g.conversation_id);let o=a.from("conversations").select("id").in("id",_);e.request_id?o=o.eq("request_id",e.request_id):o=o.is("request_id",null),e.offer_id?o=o.eq("offer_id",e.offer_id):o=o.is("offer_id",null),e.order_id?o=o.eq("order_id",e.order_id):o=o.is("order_id",null);const{data:f}=await o.limit(1);if(f&&f.length>0)return console.log("Found existing conversation:",f[0].id),await this.getConversationById(f[0].id)}}const{data:i,error:m}=await a.from("conversations").insert({request_id:e.request_id||null,offer_id:e.offer_id||null,order_id:e.order_id||null}).select().single();if(m)throw console.error("Error creating conversation:",m),m;console.log("Created new conversation:",i.id);const l=[r.id,e.participant_user_id];let c=0;for(const d of l){const{error:u}=await a.from("conversation_participants").insert({conversation_id:i.id,user_id:d});u?u.code==="23505"||u.message?.includes("duplicate")?(console.warn(`Participant ${d} already exists in conversation ${i.id}`),c++):console.error("Error adding participant:",u):c++}if(c===0)throw new Error("Failed to add any participants");return console.log(`Added ${c}/${l.length} participants`),await this.getConversationById(i.id)}catch(r){return console.error("Error getting or creating conversation:",r),null}}async getConversationById(e){try{const{data:{user:r}}=await a.auth.getUser();if(!r)throw new Error("User not authenticated");const{data:t,error:n}=await a.from("conversations").select("*").eq("id",e).single();if(n)throw n;const{data:s,error:i}=await a.from("conversation_participants").select("*").eq("conversation_id",e);if(console.log("Participants query result:",{conversationId:e,participantCount:s?.length,participants:s,error:i}),i)throw console.error("Error fetching participants:",i),i;!s||s.length===0?console.warn("No participants found for conversation:",e):s.length===1&&console.warn("Only 1 participant found (expected 2):",{conversationId:e,participant:s[0]});const m=s.find(d=>d.user_id!==r.id),l=s.find(d=>d.user_id===r.id);let c=null;if(m){const{data:d,error:u}=await a.from("users").select("id, nickname, avatar, name").eq("id",m.user_id).single();!u&&d&&(c={id:d.id,nickname:d.nickname||d.name||"Unknown User",image:d.avatar||"",is_online:!1})}return{...t,participants:s,other_user:c||void 0,my_participant:l}}catch(r){return console.error("Error getting conversation:",r),null}}async getMyConversations(){try{const{data:{user:e}}=await a.auth.getUser();if(!e)throw new Error("User not authenticated");const{data:r,error:t}=await a.from("conversation_participants").select("conversation_id").eq("user_id",e.id).eq("is_archived",!1);if(t)throw t;const n=r.map(l=>l.conversation_id);if(n.length===0)return[];const{data:s,error:i}=await a.from("conversations").select("*").in("id",n).order("updated_at",{ascending:!1});if(i)throw i;return await Promise.all(s.map(async l=>{const{data:c}=await a.from("conversation_participants").select("*").eq("conversation_id",l.id),d=c?.find(o=>o.user_id!==e.id),u=c?.find(o=>o.user_id===e.id);let _=null;if(d){const{data:o}=await a.from("users").select("id, nickname, avatar, name").eq("id",d.user_id).single();o&&(_={id:o.id,nickname:o.nickname||o.name||"User",image:o.avatar||"",is_online:!1})}return{...l,participants:c||[],other_user:_||void 0,my_participant:u}}))}catch(e){return console.error("Error getting conversations:",e),[]}}async sendMessage(e){try{const{data:{user:r}}=await a.auth.getUser();if(!r)throw new Error("User not authenticated");const t={conversation_id:e.conversation_id,sender_id:r.id,content:e.content,message_type:e.message_type||"text"};e.image_url&&(t.image_url=e.image_url),e.document_url&&(t.document_url=e.document_url),e.document_name&&(t.document_name=e.document_name),e.location_name&&(t.location_name=e.location_name),e.location_address&&(t.location_address=e.location_address),e.location_lat&&(t.location_lat=e.location_lat),e.location_lng&&(t.location_lng=e.location_lng);const{data:n,error:s}=await a.from("messages").insert(t).select().single();if(s)throw s;const{data:i}=await a.from("users").select("id, nickname, avatar, name").eq("id",r.id).single();return{...n,sender:i?{id:i.id,nickname:i.nickname||i.name||"User",image:i.avatar||null}:void 0}}catch(r){return console.error("Error sending message:",r),null}}async getMessages(e,r=50,t){try{let n=a.from("messages").select("*").eq("conversation_id",e).eq("is_deleted",!1).order("created_at",{ascending:!1}).limit(r);t&&(n=n.lt("created_at",t));const{data:s,error:i}=await n;if(i)throw i;return(await Promise.all(s.map(async l=>{const{data:c}=await a.from("users").select("id, nickname, avatar, name").eq("id",l.sender_id).single();return{...l,sender:c?{id:c.id,nickname:c.nickname||c.name||"User",image:c.avatar||null}:void 0}}))).reverse()}catch(n){return console.error("Error getting messages:",n),[]}}async markAsRead(e){try{const{data:{user:r}}=await a.auth.getUser();if(!r)throw new Error("User not authenticated");const{error:t}=await a.from("conversation_participants").update({last_read_at:new Date().toISOString(),unread_count:0}).eq("conversation_id",e.conversation_id).eq("user_id",r.id);if(t)throw t;return!0}catch(r){return console.error("Error marking as read:",r),!1}}async togglePin(e){try{const{data:{user:r}}=await a.auth.getUser();if(!r)throw new Error("User not authenticated");const{data:t}=await a.from("conversation_participants").select("is_pinned").eq("conversation_id",e).eq("user_id",r.id).single();if(!t)return!1;const{error:n}=await a.from("conversation_participants").update({is_pinned:!t.is_pinned}).eq("conversation_id",e).eq("user_id",r.id);if(n)throw n;return!0}catch(r){return console.error("Error toggling pin:",r),!1}}async archiveConversation(e){try{const{data:{user:r}}=await a.auth.getUser();if(!r)throw new Error("User not authenticated");const{error:t}=await a.from("conversation_participants").update({is_archived:!0}).eq("conversation_id",e).eq("user_id",r.id);if(t)throw t;return!0}catch(r){return console.error("Error archiving conversation:",r),!1}}subscribeToMessages(e,r){console.log("ðŸ”” Setting up real-time subscription for conversation:",e);const t=a.channel(`messages:${e}`).on("postgres_changes",{event:"INSERT",schema:"public",table:"messages",filter:`conversation_id=eq.${e}`},async n=>{console.log("ðŸ“¨ Real-time message received:",n.new);const s=n.new,{data:i}=await a.from("users").select("id, nickname, avatar, name").eq("id",s.sender_id).single(),m={...s,sender:i?{id:i.id,nickname:i.nickname||i.name||"User",image:i.avatar||null}:void 0};console.log("ðŸ“¨ Calling callback with message:",m),r(m)}).subscribe(n=>{console.log("ðŸ”” Subscription status:",n)});return this.conversationSubscriptions.set(e,t),t}subscribeToConversations(e){return a.channel("conversations").on("postgres_changes",{event:"*",schema:"public",table:"conversations"},t=>{(t.eventType==="UPDATE"||t.eventType==="INSERT")&&e(t.new)}).subscribe()}unsubscribeFromMessages(e){const r=this.conversationSubscriptions.get(e);r&&(a.removeChannel(r),this.conversationSubscriptions.delete(e))}unsubscribeAll(){this.conversationSubscriptions.forEach(e=>{a.removeChannel(e)}),this.conversationSubscriptions.clear()}async deleteMessage(e){try{const{data:{user:r}}=await a.auth.getUser();if(!r)throw new Error("User not authenticated");const{error:t}=await a.from("messages").update({is_deleted:!0,content:"Message deleted"}).eq("id",e).eq("sender_id",r.id);if(t)throw t;return!0}catch(r){return console.error("Error deleting message:",r),!1}}async editMessage(e,r){try{const{data:{user:t}}=await a.auth.getUser();if(!t)throw new Error("User not authenticated");const{error:n}=await a.from("messages").update({content:r,is_edited:!0,updated_at:new Date().toISOString()}).eq("id",e).eq("sender_id",t.id);if(n)throw n;return!0}catch(t){return console.error("Error editing message:",t),!1}}}const w=new p;export{w as c};
